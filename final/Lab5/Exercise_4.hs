module Lab5Ex4 where
 
import Data.List
import System.Random
import Lecture5
import Data.Char
import System.Random
import System.IO.Unsafe


-- ============================
-- == Exercise 4 == 2.5 hours
-- ============================

{-  Findings report:
The function sud3emptyGen generates sudokus with three empty blocks. These are minimized, but the minimization really only makes sense if the three blocks that are randomly chosen aren't in line with each other, i.e, not in the same row or column. This is because if they do align, the problem becomes ambiguous. This is immediately an answer to whether we can build puzzles with more than 3 emtpy blocks: no. If we take 4 empty blocks in the sudoku, at least two of them occur in the same row or column, causing them to be ambiguous and invalid sudokus.
The provided implementation generates random sudokus with randomly chosen blocks to wipe, which causes it to sometimes provide valid sudokus and sometimes not. Below is an example of what a valid puzzle with three empty blocks generated by this function.

@TODO Katarina: Further explain ambiguity argument

-}

sud3emptyGen :: IO ()
sud3emptyGen = do
    (sud, _) <- genRandomSudoku
    let grid = sud2grid sud
        node = initNode (wipeNblocks grid 3)
    min <- genProblem (head node)
    return min >>= showNode

-- helper function to get random integer value
randInt' :: Int -> Int -> IO Int
randInt' low high = do
    value <- getStdRandom (randomR (low, high))
    return value

randInt :: Int -> Int -> Int
randInt a b = unsafePerformIO (randInt' a b)

-- @TODO Martin remove unsafePerformIO

wipeNblocks :: Grid -> Int -> Grid
wipeNblocks grid n =
    let subSetToWipe = takeRandomSubset positions n []
    in wipeBlocks grid subSetToWipe

wipeBlocks :: Grid -> [Int] -> Grid
wipeBlocks grid [] = grid
wipeBlocks grid (x:xs) = wipeBlocks (wipeBlock grid x) xs

wipeBlock :: Grid -> Int -> Grid
wipeBlock grid 1 = putZerosAt grid [(r,c) | r <- [1..3], c <- [1..3]]
wipeBlock grid 2 = putZerosAt grid [(r,c) | r <- [4..6], c <- [1..3]]
wipeBlock grid 3 = putZerosAt grid [(r,c) | r <- [7..9], c <- [1..3]]
wipeBlock grid 4 = putZerosAt grid [(r,c) | r <- [1..3], c <- [4..6]]
wipeBlock grid 5 = putZerosAt grid [(r,c) | r <- [4..6], c <- [4..6]]
wipeBlock grid 6 = putZerosAt grid [(r,c) | r <- [7..9], c <- [4..6]]
wipeBlock grid 7 = putZerosAt grid [(r,c) | r <- [1..3], c <- [7..9]]
wipeBlock grid 8 = putZerosAt grid [(r,c) | r <- [4..6], c <- [7..9]]
wipeBlock grid 9 = putZerosAt grid [(r,c) | r <- [7..9], c <- [7..9]]

-- @TODO Jelle rewrite wipeBlock in one line

-- inspairation taken from Second answer (by Don Stewart) to this question:
-- https://stackoverflow.com/questions/5852722/replace-individual-list-elements-in-haskell
putZeroAt :: Grid -> (Int, Int) -> Grid
putZeroAt grid (r,c) = 
    let (rowsBefore,thisRow:rowsAfter) = splitAt (r-1) grid
        (colsBefore,_:colsAfter) = splitAt (c-1) thisRow
    in  rowsBefore ++ [colsBefore ++ [0] ++ colsAfter] ++ rowsAfter

putZerosAt :: Grid -> [(Int, Int)] -> Grid
putZerosAt grid [] = grid
putZerosAt grid (x:xs) = putZerosAt (putZeroAt grid x) xs

takeRandomSubset :: [Int] -> Int -> [Int] -> [Int]
takeRandomSubset [] _ collector = collector
takeRandomSubset _ 0 collector = collector
takeRandomSubset currSet n collector = 
    let index = randInt 0 (length currSet - 1)
        thisItem = currSet !! index
        (x,_:ys) = splitAt index currSet
    in takeRandomSubset (x ++ ys) (n-1) (thisItem:collector)

{-  Result:
*Lab5> sud3emptyGen 
+-------+-------+-------+
|   2 6 |       |   5   |
| 8     |       | 7 2   |
| 7   4 |       |     3 |
+-------+-------+-------+
| 3 4   | 9     |       |
|       |   8 2 |       |
| 6 8 2 |   1   |       |
+-------+-------+-------+
|       |     3 |     7 |
|       | 4 2   | 1   8 |
|       | 1     | 9     |
+-------+-------+-------+
-}
